"for" {strcpy(yylval.cadena,yytext); return FOR;}
"while" {strcpy(yylval.cadena,yytext); return WHILE;}
"do" {strcpy(yylval.cadena,yytext); return DO;}
"switch" {strcpy(yylval.cadena,yytext); return SWITCH;}
"break" {strcpy(yylval.cadena,yytext); return BREAK;}
"case" {strcpy(yylval.cadena,yytext); return CASE;}
"default" {strcpy(yylval.cadena,yytext); return DEFAULT;}
"return" {strcpy(yylval.cadena,yytext); return RETURN;}
"if" {strcpy(yylval.cadena,yytext); return IF;}
"else" {strcpy(yylval.cadena,yytext); return ELSE;}


({DIGITO_DECIMAL}*\.{DIGITO_DECIMAL}+|{DIGITO_DECIMAL}+\.|{DIGITO_DECIMAL}+)([eE][\+\-]?{DIGITO_DECIMAL}+)? {yylval.real = atoi(yytext); return REAL;}


{ESTRUCTURA_DE_CONTROL} {strcpy(yylval.cadena,yytext); return ESTRUCTURA_DE_CONTROL;}
{PALABRA_RESERVADA} {strcpy(yylval.cadena,yytext); return PALABRA_RESERVADA;}

{OPERADOR} {yylval.caracter = atoi(yytext); return OPERADOR}
"++"|"--"|"->"|<=|==|!=|!!|&&|"||"|"+="|"-="|"*="|"/="|%=|>>=|<<=|&=|"|="|"^="|"?:"|<<|>>|"^"|[\+\-\*/%~&!=<>\|] { cargarSinRepetir(listaOper_CarPunt, yytext, OPERADOR);}
\.\.\.|[.|,|;|:|#|\[|\]|\{|\}|\(|\)] { cargarSinRepetir(listaOper_CarPunt, yytext, PUNTUACION);}

\/\*(\\.|[^\\*\/])*\*\/  {strcpy(yylval.cadena,yytext); return COMENTARIO;}
\/\/(\\.|[^\n])*  {strcpy(yylval.cadena,yytext); return COMENTARIO;}

"#define"/" "{IDENTIFICADOR} {CONTADOR_DEFINE += 1;}
"#include"/" "{CONDICION} {CONTADOR_INCLUDE += 1;}


ESTRUCTURA_DE_CONTROL break|case|continue|do|else|for|goto|if|return|switch|while


listaDeclaracionesOP: 
  | listaDeclaraciones
;
s
listaDeclaraciones: declaVarSimples
  | listaDeclaraciones declaVarSimples
;

listaSentenciasOP:
  | listaSentencias
;

"->"|!!|"-="|"*="|"/="|%=|>>=|<<=|&=|"|="|"^="|"?:"|<<|>>|"^"|[%~\|] {strcpy(yylval.cadena,yytext); return OPERADOR;}

\.\.\.|[.|#] {strcpy(yylval.cadena,yytext); return PUNTUACION;}

({DIGITO_DECIMAL}*\.{DIGITO_DECIMAL}+|{DIGITO_DECIMAL}+\.|{DIGITO_DECIMAL}+)([eE][\+\-]?{DIGITO_DECIMAL}+)? {yylval.real = atof(yytext); return CONS_REAL;}





----------DECLARACION---------



declaracion: declaVarSimples
  | declaStruct
;

declaStruct:  STRUCT IDENTIFICADOR '{' TIPO_DATO listaDeVariables ';' soloDeclarar '}' IDENTIFICADOR ';' {printf("Se encontr√≥ un struct \n");}
  | STRUCT IDENTIFICADOR '{' TIPO_DATO listaDeVariables ';' soloDeclarar '}' ';' {printf("Se encontro un struct \n");}
;


soloDeclarar: 
  | TIPO_DATO listaDeVariables ';' soloDeclarar
;

declaVarSimples: TIPO_DATO  {printf("se declaro una variable de tipo %s \n", $<cadena>1);}  listaVarSimples ';'
  | error caracterDeCorte {printf("Falta tipo de dato \n");}
;

listaVarSimples: unaVarSimple
	| listaVarSimples ',' unaVarSimple
;

unaVarSimple: variable inicial
	| variable
  | variable '[' NUM ']'
;

listaDeVariables: variable
  | variable ',' variable
;

variable: IDENTIFICADOR 
;

inicial: OPER_ASIGNACION CONSTANTE 
;

CONSTANTE: NUM
  | LIT_CADENA
  | CARACTER
  | error {flag_error=1;printf("constante no valida \n");}
;

caracterDeCorte:	';' | '\n'
;